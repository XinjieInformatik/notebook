# Leetcode 专题整理
### 位操作
#### [136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)
```
给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
```
```python
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        val = 0
        for num in nums:
            val ^= num
        return val
```

#### [137. 只出现一次的数字 II](https://leetcode-cn.com/problems/single-number-ii/)
```
给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了m=3次。找出那个只出现了一次的元素。
```
统计nums数组中二进制1的出现次数,%m,剩下的就是只出现了一次的数字
```python
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        count = [0 for i in range(32)]
        for num in nums:
            for i in range(32):
                count[i] += num & 1
                num >>= 1
        res = 0
        m = 3
        for i in range(31,-1,-1):
            res <<= 1 # 放在前面避免多左移一次
            res |= count[i] % m
        # 将数字32位以上取反，32位以下不变。
        if count[-1] % m != 0:
            res = ~(res ^ 0xffffffff)
        return res
```
#### [287. 寻找重复数](https://leetcode-cn.com/problems/find-the-duplicate-number/)
```python

```
#### [169. 多数元素](https://leetcode-cn.com/problems/majority-element/)
```
```
```python
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        n = len(nums)
        count = [0 for i in range(32)]
        for num in nums:
            for i in range(32):
                count[i] += num & 1
                num >>= 1
        res = 0
        for i in range(32):
            if count[i] > n/2:
                res |= (1<<i)
        # 将数字32位以上取反，32位以下不变。
        if res >= 1<<31:
            res = ~(res ^ 0xffffffff)
        return res
```

#### [229. 求众数 II](https://leetcode-cn.com/problems/majority-element-ii/)
#### [1018. 可被 5 整除的二进制前缀](https://leetcode-cn.com/problems/binary-prefix-divisible-by-5/)

## 动态规划
### 背包问题
0-1背包: 416, 474, 494. 背包: 322, 518, 1449.
- 整体框架就是for i 遍历物体, for j 遍历重量维度
- 注意初始化需不需要修改dp
- 01背包在 物体i-1重量j维度 逆序遍历,保证每个物体只使用一次
- 多重背包在 物体i重量j维度 正向遍历,保证物体可以重复使用
**dp二维改一维,还是双重循环,框架不变,只是dp只使用重量j的维度**
#### [简化01背包](https://www.lintcode.com/problem/backpack/description)
```在n个物品中挑选若干物品装入背包，最多能装多满？假设背包的大小为m，每个物品的大小为A[i]
```
```python
class Solution:
    def backPack(self, m, A):
        # --- 递归
        n = len(A)  
        dp = [[0 for i in range(m+1)] for j in range(n+1)]
        def helper(index, curr):
            if index == n:
                dp[index][curr] = curr
                return dp[index][curr]
            if dp[index][curr] > 0:
                return dp[index][curr]
            res = 0
            if curr+A[index] <= m:
                pick = helper(index+1, curr+A[index])
                not_pick = helper(index+1, curr)
                res = max(pick, not_pick)
            else:
                not_pick = helper(index+1, curr)
                res = not_pick
            dp[index][curr] = res
            return res
        return helper(0,0)

        #--- 二维数组
        n, m = len(A)+1, m+1
        dp = [[0 for j in range(m)] for i in range(n)]
        for i in range(1, n):
            for j in range(m-1, 0, -1):
                if j < A[i-1]:
                    dp[i][j] = dp[i-1][j]
                else:
                    dp[i][j] = max(dp[i-1][j], dp[i-1][j-A[i-1]]+A[i-1])
        # print(dp)
        return dp[-1][-1]

        #--- 一维数组
        n, m = len(A)+1, m+1
        dp = [0] * m
        for i in range(1, n):
            # 01背包逆序,完全背包正序
            for j in range(m, 0, -1):
                if j < A[i-1]:
                    continue
                dp[j] = max(dp[j], dp[j-A[i-1]]+A[i-1])
            # print(dp)
        return dp[-1]
```
#### [经典01背包](https://www.lintcode.com/problem/backpack-ii/description)
```有 n 个物品和一个大小为 m 的背包. 给定数组 A 表示每个物品的大小和数组 V 表示每个物品的价值.
问最多能装入背包的总价值是多大?
```
为什么不能 return value
```python
class Solution:
    def backPackII(self, m, A, V):
        #-- 搜索
        n = len(A)
        dp = [[0 for i in range(m+1)] for j in range(n+1)]
        def helper(index, value, weight):
            if index == n:
                return 0
            if dp[index][weight]:
                return dp[index][weight]
            res = 0
            if weight + A[index] <= m:
                pick = helper(index+1, value, weight+A[index])+V[index]
                not_pick = helper(index+1, value, weight)
                res = max(pick, not_pick)
            else:
                not_pick = helper(index+1, value, weight)
                res = not_pick
            dp[index][weight] = res
            return res

        return helper(0, 0, 0)

        #--- 二维dp
        n, m = len(A)+1, m+1
        dp = [[0 for j in range(m)] for i in range(n)]
        for i in range(1, n):
            for j in range(m-1, 0, -1):
                if j < A[i-1]:
                    dp[i][j] = dp[i-1][j]
                else:
                    dp[i][j] = max(dp[i-1][j], dp[i-1][j-A[i-1]]+V[i-1])
        return dp[-1][-1]

        #--- 一维dp
        n, m = len(A)+1, m+1
        dp = [0 for i in range(m)]
        for i in range(1, n):
            for j in range(m-1, -1, -1):
                if j < A[i-1]:
                    continue
                else:
                    dp[j] = max(dp[j], dp[j-A[i-1]]+V[i-1])
        return dp[-1]
```
#### [563. 背包问题 V](https://www.lintcode.com/problem/backpack-v/my-submissions)
```给出 n 个物品, 以及一个数组, nums[i] 代表第i个物品的大小, 保证大小均为正数,
正整数 target 表示背包的大小, 找到能填满背包的方案数。每一个物品只能使用一次
```
```python
class Solution:
    """01背包问题,爬楼梯升级版,求排列数
    如果装的下, dp[i][j] = 上一个物品j重量的排列数+上一个物品j-w的排列数
    else        dp[i][j] = 上一个物品j重量的排列数
    """
    def backPackV(self, nums, target):
        # --- 二维dp
        # 1. 初始化dp数组
        n, m = len(nums)+1, target+1
        dp = [[0 for j in range(m)] for i in range(n)]
        for i in range(n):
            dp[i][0] = 1
        # 2. 按顺序遍历dp填表
        for i in range(1, n):
            for j in range(1, m):
                # 3. 状态转移方程
                if j - nums[i-1] < 0:
                    dp[i][j] = dp[i-1][j]
                else:
                    dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i-1]]
        # print(dp)
        # 4. 最终返回状态
        return dp[-1][-1]

        # --- 一维dp
        dp = [0] * (target+1)
        dp[0] = 1
        n = len(nums)
        for i in range(n):
            for j in range(target, nums[i]-1, -1):
                dp[j] = dp[j-nums[i]] + dp[j]
            print(dp)
        return dp[-1]

        # --- 搜索
        n = len(nums)
        memo = [[0 for i in range(target)] for j in range(n)]
        def helper(index, curr):
            if curr == target:
                return 1
            if curr > target or index == n:
                return 0
            if memo[index][curr]:
                return memo[index][curr]
            pick = helper(index+1, curr+nums[index])
            not_pick = helper(index+1, curr)
            res = pick + not_pick
            memo[index][curr] = res
            return res
        return helper(0, 0)
```
#### [562. 背包问题 IV](https://www.lintcode.com/problem/backpack-iv/description)
```给出 n 个物品, 以及一个数组, nums[i]代表第i个物品的大小, 保证大小均为正数并且没有重复,
正整数 target 表示背包的大小, 找到能填满背包的方案数。每一个物品可以使用无数次
```
#### [518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)
```python
class Solution:
    def backPackIV(self, nums, target):
        # 1. 初始化dp
        n = len(nums)+1
        m = target+1
        dp = [[0 for j in range(m)] for i in range(n)]
        for i in range(n):
            dp[i][0] = 1
        # 2. 按规则遍历dp填表
        for i in range(1, n):
            for j in range(1, m):
                # 3. 状态转移
                if j - nums[i-1] < 0:
                    dp[i][j] = dp[i-1][j]
                else:
                    dp[i][j] = dp[i-1][j] + dp[i][j-nums[i-1]]
        # 4. 输出最终状态
        # for line in dp: print(line)
        return dp[-1][-1]
```

#### [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)
```给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。
如果没有任何一种硬币组合能组成总金额，返回 -1。
```
```python
from collections import deque
import functools
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        """bfs"""
        coins = sorted(coins, reverse=True)
        queue = deque([(amount,0)])
        visited = set([amount])
        while queue:
            top, step = queue.pop()
            if top == 0:
                return step
            for coin in coins:
                res = top - coin
                if res >= 0 and res not in visited:
                    visited.add(res)
                    queue.appendleft((res,step+1))
        return -1

        """dp搜索,记忆化枚举所有状态,对于符合条件返回的状态取最小值"""
        @functools.lru_cache(None)
        def helper(amount):
            if amount == 0:
                return 0
            if amount < 0:
                return None
            res = 0xffffffff
            for coin in coins:
                ans = helper(amount-coin)
                if ans != None:
                    res = min(ans+1, res)
            return res

        ans = helper(amount)
        if ans == 0xffffffff: ans = -1
        return ans

        """dp数组, dp[i]定义为组成金额i所需最少的硬币数"""
        dp = [0xffffffff for i in range(amount+1)]
        dp[0] = 0
        for coin in coins:
            for i in range(coin, amount+1):
                dp[i] = min(dp[i], dp[i-coin]+1)
        # print(dp)
        return dp[-1] if dp[-1] != 0xffffffff else -1
```

#### [518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)
完全背包问题
70爬楼梯求的是排列数,该题需要求组合数,用递归思路很不直接.因此用dp二维数组,大小(n+1, m+1).
行是coins,列是amount. 初始化dp[i][0]为1,因为amount为0的时候,组合数为1.
然后从上到下,从左到右填表. 状态转移:
1. amount能够使用该硬币,则 dp[i][j] = 使用该硬币组合数+不使用该硬币组合数
2. amount不足以使用该硬币, dp[i][j] = 不使用该硬币组合数
```python
class Solution:
    def change(self, amount: int, coins: List[int]) -> int:
        """如果装的下: dp[i][j] = 上一个物品重量j的组合数+该物品重量j-w的组合数
           else:     dp[i][j] = 上一个物品重量j的组合数
           完全背包+该物品重量j-w,因为可以重复使用,01背包+上一个物品重量j-w组合数
           对于滚动数组,完全背包是正向遍历,01背包反向遍历
        """
        # dp = [0] * (amount + 1)
        # dp[0] = 1
        # for coin in coins:
        #     for x in range(coin, amount + 1):
        #         dp[x] = dp[x-coin] + dp[x]
        #     print(dp)
        # return dp[amount]

        n, m = len(coins)+1, amount+1
        dp = [[0 for i in range(m)] for j in range(n)]
        for i in range(n):
            dp[i][0] = 1
        for i in range(1, n):
            for j in range(1, m):
                if j < coins[i-1]:
                    dp[i][j] = dp[i-1][j]
                else:
                    dp[i][j] = dp[i][j-coins[i-1]] + dp[i-1][j]
        return dp[-1][-1]
```

#### [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)
```python
class Solution:
    def climbStairs(self, n: int) -> int:
        ## dp 1维数组
        if n == 1: return 1
        dp = [0] * n
        dp[0] = 1
        dp[1] = 2
        for i in range(2, n):
            dp[i] = dp[i-1] + dp[i-2]
        return dp[-1]

        ## dp 常数
        if n == 1: return 1
        if n == 2: return 2
        prev = 1
        curr = 2
        nxt = 0
        for i in range(2, n):
            nxt = prev + curr
            prev = curr
            curr = nxt
        return nxt

        ## 枚举+记忆
        import functools
        @functools.lru_cache(None)
        def helper(step):
            if step == 0:
                return 1
            if step < 0:
                return 0
            res = 0
            res += helper(step-1)
            res += helper(step-2)
            return res
        return helper(n)
```

#### [77. 组合](https://leetcode-cn.com/problems/combinations/)
```给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。
输入: 3, 2  输出: [[1,2],[1,3],[2,3]]
```
1. 每次从上一index+1开始遍历
2. 如果 已选+剩余可选 < k: break
3. results.append()后要return
```python
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        results = []
        def helper(index, res):
            if len(res) == k:
                results.append(res)
                return # 重要,避免之后无效的递归
            for i in range(index, n+1):
                # 重要,if 已选+剩余可选 < k: break
                if len(res)+n-i+1 < k:
                    break
                helper(i+1, res+[i])
        helper(1, [])
        return results
```

#### [78. 子集](https://leetcode-cn.com/problems/subsets/)
```给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。
输入: nums = [1,2,3]
输出:[[3],[1],[2],[1,2,3],[1,3],[2,3],[1,2],[]]
```
1. 注意是i+1 不是 index+1
```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        n = len(nums)
        results = []
        def helper(index, res):
            if index > n:
                return
            results.append(res)
            for i in range(index, n):
                helper(i+1, res+[nums[i]])
        helper(0, [])
        return results
```

#### [46. 全排列](https://leetcode-cn.com/problems/permutations/)
```给定一个 没有重复 数字的序列，返回其所有可能的全排列。
输入: [1,2,3]
输出: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```
1. 每次都从index为0开始遍历
2. 当前数字不能在已添加数字里
```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        results = []
        n = len(nums)
        def helper(res):
            if len(res) == n:
                results.append(res)
                return
            for i in range(0, n):
                if nums[i] not in res:
                    helper(res+[nums[i]])
        helper([])
        return results
```

#### [47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/)
```给定一个可包含重复数字的序列，返回所有不重复的全排列。
输入: [1,1,2]   输出: [[1,1,2],[1,2,1],[2,1,1]]
```
```python
from collections import Counter
class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        n = len(nums)
        count = Counter(nums)
        results = []
        def helper(res, count):
            if len(res) == n:
                results.append(res)
                return
            for i in range(n):
                # 跳过重复数字
                if i != 0 and nums[i] == nums[i-1]:
                    continue
                # 跳过用尽数字
                if count[nums[i]] == 0:
                    continue
                count[nums[i]] -= 1
                helper(res+[nums[i]], count)
                count[nums[i]] += 1
        helper([], count)
        return results
```


### 二维dp(字符串)
#### [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)
```给定一个字符串 s，找到 s 中最长的回文子串。
输入: "babad" 输出: "bab" 注意: "aba" 也是一个有效答案。
```
从上到下,从左到右
```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        n = len(s)
        if n == 0: return ""
        dp = [[0 for i in range(n)] for j in range(n)]
        for i in range(n):
            dp[i][i] = 1
        max_len, max_i, max_j = 0, 0, 0
        for j in range(n):
            for i in range(j):
                if s[i] == s[j]:
                    if j-i < 2:
                        dp[i][j] = 1
                    elif dp[i+1][j-1]:
                        dp[i][j] = 1
                if dp[i][j] and j-i > max_len:
                    max_len = j-i
                    max_i, max_j = i, j
        return s[max_i:max_j+1]
```

#### [516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)
```给定一个字符串s，找到其中最长的回文子序列，并返回该序列的长度。 输入: "bbbab"  输出: 4
```
从下到上,从右到左
```python
class Solution:
    def longestPalindromeSubseq(self, s: str) -> int:
        n = len(s)
        dp = [[0 for j in range(n)] for i in range(n)]
        for i in range(n):
            dp[i][i] = 1
        for i in range(n-2, -1, -1):
            for j in range(i+1, n):
                if s[i] == s[j]:
                    dp[i][j] = dp[i+1][j-1] + 2
                else:
                    dp[i][j] = max(dp[i+1][j], dp[i][j-1])
        return dp[0][-1]
```

#### [1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)
```给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。
例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列.
```
```python
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        """
        dp[i][j] 定义为s1到i的子串, s2到j的子串的公共子序列长度, 长度为(n+1,m+1)
        状态转移如代码
        """
        dp = [[0 for j in range(len(text2)+1)] for i in range(len(text1)+1)]
        for i in range(len(text1)):
            for j in range(len(text2)):
                if text1[i] == text2[j]:
                    dp[i+1][j+1] = max(dp[i][j]+1, dp[i+1][j], dp[i][j+1])
                else:
                    dp[i+1][j+1] = max(dp[i+1][j], dp[i][j+1])
        return dp[-1][-1]
```

#### [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)
```给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数
你可以对一个单词： 插入一个字符 删除一个字符
输入：word1 = "horse", word2 = "ros"  输出：3
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```
```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        n, m = len(word1), len(word2)
        dp = [[0 for i in range(m+1)] for j in range(n+1)]
        # init
        for i in range(n+1):
            dp[i][0] = i
        for j in range(m+1):
            dp[0][j] = j
        # dp
        for i in range(1,n+1):
            for j in range(1,m+1):
                if word1[i-1] == word2[j-1]:
                    dp[i][j] = dp[i-1][j-1]
                else:
                    dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1
        return dp[n][m]
```

#### [正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)
递归中枚举所有情况,加上记忆化
```python
import functools
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        @functools.lru_cache(None)
        def helper(text, pattern):
            if len(pattern) == 0: return text == ""
            match =  len(text) != 0 and (pattern[0] == text[0] or pattern[0] == ".")
            if len(pattern) > 1 and pattern[1] == "*":
                return helper(text, pattern[2:]) or (match and helper(text[1:], pattern))
            return match and helper(text[1:], pattern[1:])
        return helper(s, p)
```

### 最大子序问题
1. 定义状态
2. 推导状态转移方程
3. 初始化
4. 输出

#### [152. 乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/)
```给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。
输入: [2,3,-2,4]  输出: 6
```
```python
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        """
        dp[i][0]: 到数组index为i的元素,最近一段连续的最小乘积
        dp[i][1]: 到数组index为i的元素,最近一段连续的最大乘积
        """
        n = len(nums)
        # 注意２在里面，ｎ在外面
        dp = [[0 for i in range(2)] for j in range(n)]
        # 初始化
        if n == 0: return None
        dp[0][0], dp[0][1] = nums[0], nums[0]
        res = nums[0]
        for i in range(1, n):
            # nums[i] 为正负 两种情况下状态的改变
            if nums[i] > 0:
                # min 的意思为可以在这里截断，dp[i-1]维护的是上一段连续乘积
                dp[i][0] = min(dp[i-1][0]*nums[i], nums[i])
                dp[i][1] = max(dp[i-1][1]*nums[i], nums[i])
            else:
                # 最大值变为最小值，最小值变为最大值
                dp[i][0] = min(dp[i-1][1]*nums[i], nums[i])
                dp[i][1] = max(dp[i-1][0]*nums[i], nums[i])
            res = max(res, dp[i][1])
        return res
```

滚动变量,空间优化
```python
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        """ 滚动变量
        curr_min: 到数组当前index,最近一段连续的最小乘积
        curr_max: 到数组当前index,最近一段连续的最大乘积
        注意 prev <-> curr 之间的转化
        """
        n = len(nums)
        prev_max, prev_min, res = nums[0], nums[0], nums[0]
        for i in range(1, n):
            if nums[i] > 0:
                curr_min = min(nums[i], prev_min*nums[i])
                curr_max = max(nums[i], prev_max*nums[i])
            else:
                curr_min = min(nums[i], prev_max*nums[i])
                curr_max = max(nums[i], prev_min*nums[i])
            prev_min, prev_max = curr_min, curr_max
            res = max(res, curr_max)
        return res
```

#### [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)
```给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```
```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        """
        dp[i]: 到数组i的最近一段最大和
        注意return res 而不是dp[-1]
        """
        n = len(nums)
        dp = [0 for i in range(n)]
        dp[0], res = nums[0], nums[0]
        for i in range(1, n):
            dp[i] = max(dp[i-1]+nums[i], nums[i])
            res = max(dp[i], res)
        return res
```
```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        n = len(nums)
        prev, res = nums[0], nums[0]
        for i in range(1, n):
            curr = max(prev+nums[i], nums[i])
            prev = curr
            res = max(res, curr)
        return res
```

#### [300. 最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)
```给定一个无序的整数数组，找到其中最长上升子序列的长度。
输入: [10,9,2,5,3,7,101,18]  输出: 4
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
```
O(n^2)动态规划.
- dp[j]定义为到j为止的最长上升子序列长度
- dp初始化为1, 因为非空数组至少1个上升子序列
- val = dp[i]+1 if nums[j]>nums[i]
- val = 1 截断
- dp[j] 取最大的val,在 for i in range(j)的循环中
```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        n = len(nums)
        if n == 0: return 0
        dp = [1] * n
        max_len = 0
        for j in range(n):
            for i in range(j):
                val = dp[i]+1 if nums[i] < nums[j] else 1
                dp[j] = max(dp[j], val)
            max_len = max(max_len, dp[j])
        return max_len
```
```python
class Solution:
    def low_bound(self, nums, left, right, target):
        while left < right:
            mid = left + (right-left) // 2
            if nums[mid] < target:
                left = mid + 1
            else:
                right = mid
        return left

    def lengthOfLIS(self, nums: List[int]) -> int:
        dp = []
        lenth = 0
        n = len(nums)
        for i in range(n):
            if lenth == 0:
                dp.append(nums[i])
                lenth += 1
            index = self.low_bound(dp, 0, lenth, nums[i])
            if index < lenth:
                dp[index] = nums[i]
            else:
                dp.append(nums[i])
                lenth += 1
        return len(dp)
```

#### [376. 摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/)
```如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。
第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。
输入: [1,7,4,9,2,5]   输出: 6
解释: 整个序列均为摆动序列。
```
```python
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        """
        up[i]  : 到nums[i]为止最长的上升摆动序列
        down[i]: 到nums[i]为止最长的下降摆动序列
        """
        n = len(nums)
        if n == 0: return 0
        up = [0 for i in range(n)]
        down = [0 for i in range(n)]
        up[0], down[0] = 1, 1
        for i in range(1, n):
            if nums[i] > nums[i-1]:
                up[i] = down[i-1] + 1
                down[i] = down[i-1]
            elif nums[i] < nums[i-1]:
                up[i] = up[i-1]
                down[i] = up[i-1] + 1
            else:
                up[i] = up[i-1]
                down[i] = down[i-1]
        return max(up[-1], down[-1])
```

#### [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        if n == 0: return 0
        min_price = prices[0]
        max_profit = 0
        for i in range(1, n):
            profit = prices[i] - min_price
            max_profit = max(max_profit, profit)
            min_price = min(min_price, prices[i])
        return max_profit
```
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        """
        profit0: 状态为手中无股票的最大收益
        profit1: 状态为手中有股票的最大收益
        """
        n = len(prices)
        if n == 0: return 0
        profit0 = 0
        profit1 = - prices[0]
        for i in range(n):
            profit0 = max(profit0, profit1+prices[i])
            profit1 = max(profit1, -prices[i])
        return profit0
```

#### [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        if n == 0: return 0
        profit0 = 0
        profit1 = -prices[0]
        for i in range(1, n):
            profit0 = max(profit0, profit1+prices[i])
            profit1 = max(profit1, profit0-prices[i])
        return profit0
```

#### [123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        if n == 0: return 0
        profit00 = 0
        profit01 = -prices[0]
        profit10 = 0
        profit11 = -prices[0]
        for i in range(n):
            profit00 = max(profit00, profit01+prices[i])
            profit01 = max(profit01, -prices[i])
            profit10 = max(profit10, profit11+prices[i])
            profit11 = max(profit11, profit00-prices[i])
        return profit10
```

#### [188. 买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)
```python
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        n = len(prices)
        if n == 0 or k == 0: return 0
        # 如果交易次数>天数,当作无限次交易O(n)处理
        if k >= n:
            profit0 = 0
            profit1 = -prices[0]
            for i in range(n):
                profit0 = max(profit0, profit1+prices[i])
                profit1 = max(profit1, profit0-prices[i])
            return profit0
        profit0 = [0 for i in range(k)]
        profit1 = [-prices[0] for i in range(k)]
        for i in range(1, n):
            profit0[0] = max(profit0[0], profit1[0]+prices[i])
            profit1[0] = max(profit1[0], -prices[i])
            for j in range(1, k):
                profit0[j] = max(profit0[j], profit1[j]+prices[i])
                profit1[j] = max(profit1[j], profit0[j-1]-prices[i])
        return profit0[-1]
```

#### [714. 买卖股票的最佳时机含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)
```python
class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:
        n = len(prices)
        if n == 0: return 0
        profit0 = 0
        # 注意统一状态,fee在profit0_1处减均可,注意前后统一
        profit1 = -prices[0]-fee
        for i in range(1,n):
            profit0 = max(profit0, profit1+prices[i])
            profit1 = max(profit1, profit0-prices[i]-fee)
        return profit0
```

#### [309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        if n == 0: return 0
        profit0 = [0 for i in range(n)]
        profit1 = [-prices[0] for i in range(n)]
        for i in range(1, n):
            profit0[i] = max(profit0[i-1], profit1[i-1]+prices[i])
            profit1[i] = max(profit1[i-1], profit0[i-2]-prices[i])
        return profit0[-1]
```
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        if n == 0: return 0
        profit0 = 0
        profit1 = -prices[0]
        freeze = 0
        for i in range(n):
            # 注意储存的是前一天的状态
            prev = profit0
            profit0 = max(profit0, profit1+prices[i])
            profit1 = max(profit1, freeze-prices[i])
            freeze = prev
        return profit0
```
#### []

### 单调栈
Leetcode: 402, 316, 42, 84, 739, 496, 503, 901
#### [402. 移掉K位数字](https://leetcode-cn.com/problems/remove-k-digits/)
```
给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。
输入: num = "1432219", k = 3  输出: "1219"
解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。
```
维护一个删除k次的单调递增栈
```python
class Solution:
    def removeKdigits(self, num: str, k: int) -> str:
        n = len(num)
        if k == n: return "0"
        maintain = n - k
        stack = []
        cnt = 0
        for i in range(n):
            val = int(num[i])
            # 把val<stack[-1]判断放在while,避免写break
            while stack and val < stack[-1] and cnt<k:
                    stack.pop()
                    cnt += 1
            if val == 0 and not stack: continue
            stack.append(val)
        ans = "0" if not stack else "".join(map(str, stack[:maintain]))
        return ans
```
#### [321. 拼接最大数](https://leetcode-cn.com/problems/create-maximum-number/)
```
给定长度分别为 m 和 n 的两个数组，其元素由 0-9 构成，表示两个自然数各位上的数字
。现在从这两个数组中选出 k (k <= m + n) 个数字拼接成一个新的数，要求从同一个数组
中取出的数字保持其在原数组中的相对顺序。求满足该条件的最大数。结果返回一个表示该最大数的长度为 k 的数组。
输入: nums1 = [3, 4, 6, 5] nums2 = [9, 1, 2, 5, 8, 3] k = 5
输出: [9, 8, 6, 5, 3]
```
```python
class Solution:
    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:
        """
        从nums1选取m,nums2选取k-m. 遍历i [0,k], 取最大值
        """
        def pick(m, nums):
            stack = []
            n = len(nums)
            t = n-m
            for i in range(n):
                while stack and nums[i]>stack[-1] and t>0:
                    stack.pop()
                    t -= 1
                stack.append(nums[i])
            return stack[:m]

        def merge(nums1, nums2):
            res = []
            p1, p2 = 0, 0
            while p1 < len(nums1) and p2 < len(nums2):
                # 注意,这里一定要用list比较
                if nums1[p1:] < nums2[p2:]:
                    res.append(nums2[p2])
                    p2 += 1
                else:
                    res.append(nums1[p1])
                    p1 += 1
            if p1 == len(nums1):
                res.extend(nums2[p2:])
            elif p2 == len(nums2):
                res.extend(nums1[p1:])
            return res

        max_select = [0 for i in range(k)]
        for i in range(k+1):
            if i > len(nums1) or k-i > len(nums2):
                continue
            select1 = pick(i, nums1)
            select2 = pick(k-i, nums2)
            select = merge(select1, select2)
            max_select = max(max_select, select)
        return max_select
```
#### [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)
基本思路,对每个i,其能装载的水量为, min(left_max, right_max)-curr_h
```python
class Solution:
    def trap(self, height: List[int]) -> int:
        """单调栈"""
        stack = []
        waters = 0
        for i in range(len(height)):
            while stack and height[stack[-1]] < height[i]:
                curr_i = stack.pop()
                curr_h = height[curr_i]
                if len(stack) == 0: break
                boundary = min(height[stack[-1]], height[i])
                water = (boundary - curr_h) * (i - stack[-1] - 1)
                waters += water
            stack.append(i)
        return waters
```
```python
class Solution:
    def trap(self, height: List[int]) -> int:
        """动态规划"""
        n = len(height)
        if n==0: return 0
        max_left_height = [0 for i in range(n)]
        max_right_height = [0 for i in range(n)]
        max_left_height[0] = height[0]
        max_right_height[-1] = height[-1]
        for i in range(1,n):
            max_left_height[i] = max(max_left_height[i-1], height[i])
        for i in range(n-2,-1,-1):
            max_right_height[i] = max(max_right_height[i+1], height[i])
        waters = 0
        for i in range(n):
            left_height = max_left_height[i]
            right_height = max_right_height[i]
            curr_height = height[i]
            boundary = min(left_height, right_height)
            water = boundary-curr_height
            waters += water
        return waters
```

#### [84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)
```
给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1
求在该柱状图中，能够勾勒出来的矩形的最大面积。
```
维护单调递增栈
```python
class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        heights = [0] + heights + [0]
        stack = []
        max_area = 0
        for i in range(len(heights)):
            while stack and heights[i] < heights[stack[-1]]:
                index = stack.pop()
                curr_h = heights[index]
                area = curr_h * (i - stack[-1] - 1)
                max_area = max(max_area, area)
            stack.append(i)
        return max_area
```

#### [85. 最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/)
1. 维护单调递增的栈
2. 每层统计高度,同时入栈操作
3. 注意height两头有哨兵节点0
4. 注意 area 的宽为 j-stack[-1]-1
```
输入:
 [["1","0","1","0","0"],
  ["1","0","1","1","1"],
  ["1","1","1","1","1"],
  ["1","0","0","1","0"]]
输出: 6
```
```python
class Solution:
    def maximalRectangle(self, matrix: List[List[str]]) -> int:
        n = len(matrix)
        if n == 0: return 0
        m = len(matrix[0])
        height = [0] * (m+2)
        max_area = 0
        for i in range(n):
            stack = []
            for j in range(m+2):
                if j < m:
                    if matrix[i][j] == "1":
                        height[j+1] += 1
                    else:
                        height[j+1] = 0
                while stack and height[j] < height[stack[-1]]:
                    index = stack.pop()
                    curr_h = height[index]
                    area = curr_h * (j - stack[-1] - 1)
                    max_area = max(area, max_area)
                stack.append(j)
        return max_area
```

#### [496. 下一个更大元素 I](https://leetcode-cn.com/problems/next-greater-element-i/)
```
给定两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。
nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。
输入: nums1 = [4,1,2], nums2 = [1,3,4,2].
输出: [-1,3,-1]
```
```python
class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        """基于nums2构造单调递减栈,构造hashmap"""
        stack = []
        mapping = {}
        for i in range(len(nums2)):
            while stack and nums2[i] > stack[-1]:
                val = stack.pop()
                mapping[val] = nums2[i]
            stack.append(nums2[i])

        result = [-1 for i in range(len(nums1))]
        for i, num in enumerate(nums1):
            if num in mapping:
                result[i] = mapping[num]
        return result
```
#### [503. 下一个更大元素 II](https://leetcode-cn.com/problems/next-greater-element-ii/)
```python
class Solution:
    def nextGreaterElements(self, nums: List[int]) -> List[int]:
        stack = []
        n0 = len(nums)
        result = [-1 for i in range(n0)]
        nums = nums * 2
        for i, num in enumerate(nums):
            while stack and num > nums[stack[-1]]:
                index = stack.pop()
                if index < n0:
                    result[index] = num
            stack.append(i)
        return result
```

#### [739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)
```
根据每日 气温 列表，请重新生成一个列表，对应位置的输出是需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。
例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。
```
```python
class Solution:
    def dailyTemperatures(self, T: List[int]) -> List[int]:
        stack = []
        n = len(T)
        results = [0 for i in range(n)]
        for i in range(n):
            while stack and T[i] > T[stack[-1]]:
                index = stack.pop()
                results[index] = i - index
            stack.append(i)
        return results
```

#### [901. 股票价格跨度](https://leetcode-cn.com/problems/online-stock-span/)
```python
class StockSpanner:
    def __init__(self):
        self.stack = []
        self.result = []
        self.cnt = 0
    def next(self, price: int) -> int:
        res = 1
        while self.stack and self.stack[-1][-1] <= price:
            index, pric = self.stack.pop()
            res += self.result[index]
        self.result.append(res)
        self.stack.append((self.cnt, price))
        self.cnt += 1
        return res
```

### 前缀和
#### [560. 和为K的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)
```
给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。
输入:nums = [1,1,1], k = 2  输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。
```
```python
class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        """O(n^2)"""
        # i, j = 0, 1
        # n = len(nums)
        # prefixsum = [0] * (n+1)
        # for i in range(n):
        #     prefixsum[i+1] = prefixsum[i] + nums[i]
        # cnt = 0
        # for i in range(n+1):
        #     for j in range(i+1, n+1):
        #         if prefixsum[j] - prefixsum[i] == k:
        #             cnt += 1
        # return cnt

        """O(n)前缀和 + memo, memo存储"""
        prefixsum = 0
        memo = {0:1} # becareful!
        cnt = 0
        for num in nums:
            prefixsum += num
            if prefixsum - k in memo:
                cnt += memo[prefixsum-k]
            if prefixsum in memo:
                memo[prefixsum] += 1
            else:
                memo[prefixsum] = 1
        return cnt
```

#### [974. 和可被 K 整除的子数组](https://leetcode-cn.com/problems/subarray-sums-divisible-by-k/)
```
给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目。
输入：A = [4,5,0,-2,-3,1], K = 5  输出：7
有 7 个子数组满足其元素之和可被 K = 5 整除：
[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]
```
```python
class Solution:
    def subarraysDivByK(self, A: List[int], K: int) -> int:
        n = len(A)
        total, ans = 0, 0
        memo = {0:1}
        for num in A:
            total += num
            res = total % K
            temp = memo.get(res, 0)
            ans += temp
            memo[res] = temp + 1
        return ans
```

#### [1248. 统计优美子数组](https://leetcode-cn.com/problems/count-number-of-nice-subarrays/)
```
给你一个整数数组 nums 和一个整数 k。如果某个 连续 子数组中恰好有 k 个奇数数字，我们就认为这个子数组是「优美子数组」。请返回这个数组中「优美子数组」的数目。
输入：nums = [1,1,2,1,1], k = 3  输出：2
解释：包含 3 个奇数的子数组是 [1,1,2,1] 和 [1,2,1,1] 。
```
```python
class Solution:
    def numberOfSubarrays(self, nums: List[int], k: int) -> int:
        # odd_positions = [0]  # 设定一个数组记录奇数的位置，0代表当前位置之前的一个奇数的位置(fake point)
        # for i in range(len(nums)):
        #     if nums[i] % 2 == 1:
        #         odd_positions.append(i + 1)  # 将位置压入
        # odd_positions.append(len(nums) + 1)  # len(nums)+1代表最后一个奇数位之后的奇数位置(fake point)
        # count = 0
        # for i in range(1, len(odd_positions) - k):
        #     # 当前奇数位置 i 到前一个奇数位置之间选一个位置 * i 后的第 k-1 个奇数的位置到 i 后的第 k 个奇数节点范围内选一个
        #     count += ((odd_positions[i] - odd_positions[i - 1]) *
        #               (odd_positions[i + k] - odd_positions[i + k - 1]))  # 组合数
        # return count

        """
        pre_fix: 到当前index累计奇数的个数
        pre_fix_count: 记录每个奇数个数下的不同的连续数组个数
        """
        pre_fix_count = [1] + [0] * len(nums)
        pre_fix = 0
        result = 0
        for i in range(len(nums)):
            odd = 1 if nums[i] % 2 == 1 else 0
            pre_fix += odd
            pre_fix_count[pre_fix] += 1
            if pre_fix >= k:
                result += pre_fix_count[pre_fix - k]
        return result
```


#### [1371. 每个元音包含偶数次的最长子字符串](https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/)
TODO: 再理解一下
```python
class Solution:
    def findTheLongestSubstring(self, s: str) -> int:
        res = 0
        state = [-1] * (1 << 5)
        cur, state[0] = 0, 0
        d = dict(zip('aeiou', range(5)))
        for idx, val in enumerate(s):
            tmp = -1
            if val in d:
                tmp = d[val]
            if tmp != -1:
                cur ^= 1 << tmp
            if state[cur] == -1:
                state[cur] = idx + 1
            else:
                res = max(res, idx + 1 - state[cur])
        return res
```

### 树
#### 建树
##### [108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
        def helper(left, right):
            if left >= right: return None
            mid = left + (right-left)//2
            root = TreeNode(nums[mid])
            root.left = helper(left, mid)
            root.right = helper(mid+1, right)
            return root
        return helper(0, len(nums))
```

##### [面试题07. 重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/) [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        n = len(preorder)
        # 建立哈希表，实现O(1)查询
        lookup_table = {inorder[i]: i for i in range(n)}
        # 递归中维护子树根index与子树区间范围(相对于preorder)
        def helper(root_i, left, right):
            # 如果区间相交，return叶子节点的None
            if left >= right: return
            root = TreeNode(preorder[root_i])
            # 查询子树根在中序遍历中的位置
            in_i = lookup_table[preorder[root_i]]
            # 左子树root index 根+1
            root.left = helper(root_i+1, left, in_i)
            # 右子树root index 根+左子树长度+1
            root.right = helper(root_i+in_i-left+1, in_i+1, right)
            # 层层向上返回子树的根
            return root

        root = helper(0, 0, n)
        return root
```

## 排序
### 基于比较的排序
#### 快速排序
稳定, O(nlog(n)), 最坏 O(n^2)
```
快排的最差情况什么时候发生？
1. 已排序
2. 数值全部相等（已排序的特殊情况）

快排最好的情况是，每次正好中分，复杂度为O(nlogn)。最差情况，复杂度为O(n^2)，退化成冒泡排序
为了尽量避免最差情况的发生，就要尽量使每次选择的pivot为中位数。
一般常用的方法是，对每一个数列都取一次中位数(O(n))，这样总体的快排时间复杂度仍为O(nlogn)。
更为简化的方法是，取头、中、尾的中位数(O(1))作为pivot
```
1. 通过partition操作,使得pivot左边数均<pivot,右边>=pivot
2. 递归的对pivot左边,右边分别partition
3. 递归退出条件是l>=r
```python
def qsort(array, l, r):
    def partition(arr, left, right):
        pivot_val = arr[left]
        pivot_i = left
        for i in range(left+1, right):
            if arr[i] < pivot_val:
                pivot_i += 1
                arr[pivot_i], arr[i] = arr[i], arr[pivot_i]
        arr[pivot_i], arr[left] = arr[left], arr[pivot_i]
        return pivot_i

    if l < r:
    # partition: 交换，使得pivot左边<pivot,右边>=pivot
    pivot_index = partition_2(array, l, r)
    qsort(array, l, pivot_index)
    qsort(array, pivot_index+1, r)
```

中值快排: 解决的是复杂度退化到O(n^2)的问题
```python
def qsort(array, l, r):
    def get_median(l_i, r_i, m_i):
        l_val, r_val, m_val = nums[l_i], nums[r_i], nums[m_i]
        max_val = max(l_val, r_val, m_val)
        if l_val == max_val:
            mid_i = m_i if m_val > r_val else r_i
        elif r_val == max_val:
            mid_i = m_i if m_val > l_val else l_i
        else:
            mid_i = l_i if l_val > r_val else r_i
        return mid_i

    def partition(arr, left, right):
        m_i = left + (right-left)//2
        median_i = get_median(left, right-1, m_i)
        pivot_val = arr[median_i]
        arr[median_i], arr[left] = arr[left], arr[median_i]
        pivot_i = left
        for i in range(left+1, right):
            if arr[i] < pivot_val:
                pivot_i += 1
                arr[pivot_i], arr[i] = arr[i], arr[pivot_i]
        arr[pivot_i], arr[left] = arr[left], arr[pivot_i]
        return pivot_i

    if l < r:
        pivot_i = partition(array, l, r)
        qsort(l, pivot_i)
        qsort(pivot_i+1, r)
```

双路快排: 解决的是待排序数组中大量重复数字的问题
```python
def qsort(array, l, r):
    def partition2(arr, left, right):
        """双路快排，减少重复元素partition交换次数，无法解决退化n^2"""
        pivot = arr[left]
        l = left + 1
        r = right - 1
        while (l <= r): # 注意是 <= !
            # 左指针找到第一个大于pivot的数
            while (l < right and arr[l] <= pivot):
                l += 1
            # 右指针找到第一个小于pivot的数
            while (r > left and arr[r] >= pivot):
                r -= 1
            if l < r:
                arr[l], arr[r] = arr[r], arr[l]
        arr[left], arr[r] = arr[r], arr[left] # 注意是 r
        return r

    if l < r:
        # partition: 交换，使得pivot左边<pivot,右边>=pivot
        pivot_index = partition_2(array, l, r)
        qsort(array, l, pivot_index)
        qsort(array, pivot_index+1, r)
```

#### 归并排序
1. 递归对半分数组
2. 当被分子数组长度为1时,结束递归,return子数组
3. merge 返回的左右子数组
```python
class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        def merge(l_arr, r_arr):
            p1, p2 = 0, 0
            n1, n2 = len(l_arr), len(r_arr)
            arr = []
            while p1 < n1 and p2 < n2:
                if l_arr[p1] < r_arr[p2]:
                    arr.append(l_arr[p1])
                    p1 += 1
                else:
                    arr.append(r_arr[p2])
                    p2 += 1
            if p1 == n1:
                arr.extend(r_arr[p2:])
            elif p2 == n2:
                arr.extend(l_arr[p1:])
            return arr

        def merge_sort(arr):
            if len(arr) == 1:
                return arr
            mid = len(arr) // 2
            l_arr = merge_sort(arr[:mid])
            r_arr = merge_sort(arr[mid:])
            arr = merge(l_arr, r_arr)
            return arr

        return merge_sort(nums)
```
#### 选择排序



### 滑动窗口
#### [76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)
维护两个窗口window_s, window_t, 一个变量curr. 当window_s覆盖了window_t, 移动左指针.
实现时, 用变量curr, 突破与下降临界时curr变动, 复杂度从用isvalid的O(n^2)降到O(n)
```python
from collections import Counter, defaultdict
class Solution:
    def isvalid(self, dict1, dict2):
        valid = True
        for key in dict1:
            if key in dict2 and dict1[key] <= dict2[key]:
                continue
            else:
                valid = False
                break
        return valid

    def minWindow(self, s: str, t: str) -> str:
        l, r = 0, 0
        window_s = defaultdict(int)
        window_t = Counter(t)
        require = len(window_t)
        curr = 0

        min_l, min_r, min_len = 0, 0, float("inf")
        while r < len(s):
            window_s[s[r]] += 1
            if window_s[s[r]] == window_t[s[r]]:
                curr += 1

            while l<=r and curr == require:
                if r-l+1 < min_len:
                    min_len = r-l+1
                    min_l = l
                    min_r = r
                if window_s[s[l]] == window_t[s[l]]:
                    curr -= 1
                window_s[s[l]] -= 1
                l += 1
            r += 1
        ans = s[min_l:min_r+1] if min_len != float("inf") else ""
        return ans
```
3. 无重复字符的最长子串

30. 串联所有单词的子串

76. 最小覆盖子串

159. 至多包含两个不同字符的最长子串

209. 长度最小的子数组

239. 滑动窗口最大值

567. 字符串的排列

632. 最小区间

727. 最小窗口子序列
