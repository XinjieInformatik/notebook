# Leetcode 专题整理

### 动态规划
#### 最大子序问题
1. 定义状态
2. 推导状态转移方程
3. 初始化
4. 输出

##### [152. 乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/)
```python
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        """
        dp[i][0]: 到数组index为i的元素,最近一段连续的最小乘积
        dp[i][1]: 到数组index为i的元素,最近一段连续的最大乘积
        """
        n = len(nums)
        # 注意２在里面，ｎ在外面
        dp = [[0 for i in range(2)] for j in range(n)]
        # 初始化
        if n == 0: return None
        dp[0][0], dp[0][1] = nums[0], nums[0]
        res = nums[0]
        for i in range(1, n):
            # nums[i] 为正负 两种情况下状态的改变
            if nums[i] > 0:
                # min 的意思为可以在这里截断，dp[i-1]维护的是上一段连续乘积
                dp[i][0] = min(dp[i-1][0]*nums[i], nums[i])
                dp[i][1] = max(dp[i-1][1]*nums[i], nums[i])
            else:
                # 最大值变为最小值，最小值变为最大值
                dp[i][0] = min(dp[i-1][1]*nums[i], nums[i])
                dp[i][1] = max(dp[i-1][0]*nums[i], nums[i])
            res = max(res, dp[i][1])
        return res
```

滚动变量,空间优化
```python
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        """ 滚动变量
        curr_min: 到数组当前index,最近一段连续的最小乘积
        curr_max: 到数组当前index,最近一段连续的最大乘积
        注意 prev <-> curr 之间的转化
        """
        n = len(nums)
        prev_max, prev_min, res = nums[0], nums[0], nums[0]
        for i in range(1, n):
            if nums[i] > 0:
                curr_min = min(nums[i], prev_min*nums[i])
                curr_max = max(nums[i], prev_max*nums[i])
            else:
                curr_min = min(nums[i], prev_max*nums[i])
                curr_max = max(nums[i], prev_min*nums[i])
            prev_min, prev_max = curr_min, curr_max
            res = max(res, curr_max)
        return res
```

##### [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)
```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        """
        dp[i]: 到数组i的最近一段最大和
        注意return res 而不是dp[-1]
        """
        n = len(nums)
        dp = [0 for i in range(n)]
        dp[0], res = nums[0], nums[0]
        for i in range(1, n):
            dp[i] = max(dp[i-1]+nums[i], nums[i])
            res = max(dp[i], res)
        return res
```
```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        n = len(nums)
        prev, res = nums[0], nums[0]
        for i in range(1, n):
            curr = max(prev+nums[i], nums[i])
            prev = curr
            res = max(res, curr)
        return res
```

##### [300. 最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)
```python
class Solution:
    def low_bound(self, nums, left, right, target):
        while left < right:
            mid = left + (right-left) // 2
            if nums[mid] < target:
                left = mid + 1
            else:
                right = mid
        return left

    def lengthOfLIS(self, nums: List[int]) -> int:
        dp = []
        lenth = 0
        n = len(nums)
        for i in range(n):
            if lenth == 0:
                dp.append(nums[i])
                lenth += 1
            index = self.low_bound(dp, 0, lenth, nums[i])
            if index < lenth:
                dp[index] = nums[i]
            else:
                dp.append(nums[i])
                lenth += 1
        return len(dp)
```

##### [376. 摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/)
```python
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        """
        up[i]  : 到nums[i]为止最长的上升摆动序列
        down[i]: 到nums[i]为止最长的下降摆动序列
        """
        n = len(nums)
        if n == 0: return 0
        up = [0 for i in range(n)]
        down = [0 for i in range(n)]
        up[0], down[0] = 1, 1
        for i in range(1, n):
            if nums[i] > nums[i-1]:
                up[i] = down[i-1] + 1
                down[i] = down[i-1]
            elif nums[i] < nums[i-1]:
                up[i] = up[i-1]
                down[i] = up[i-1] + 1
            else:
                up[i] = up[i-1]
                down[i] = down[i-1]
        return max(up[-1], down[-1])
```

##### [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        if n == 0: return 0
        min_price = prices[0]
        max_profit = 0
        for i in range(1, n):
            profit = prices[i] - min_price
            max_profit = max(max_profit, profit)
            min_price = min(min_price, prices[i])
        return max_profit
```
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        """
        profit0: 状态为手中无股票的最大收益
        profit1: 状态为手中有股票的最大收益
        """
        n = len(prices)
        if n == 0: return 0
        profit0 = 0
        profit1 = - prices[0]
        for i in range(n):
            profit0 = max(profit0, profit1+prices[i])
            profit1 = max(profit1, -prices[i])
        return profit0
```

##### [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        if n == 0: return 0
        profit0 = 0
        profit1 = -prices[0]
        for i in range(1, n):
            profit0 = max(profit0, profit1+prices[i])
            profit1 = max(profit1, profit0-prices[i])
        return profit0
```

##### [123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        if n == 0: return 0
        profit00 = 0
        profit01 = -prices[0]
        profit10 = 0
        profit11 = -prices[0]
        for i in range(n):
            profit00 = max(profit00, profit01+prices[i])
            profit01 = max(profit01, -prices[i])
            profit10 = max(profit10, profit11+prices[i])
            profit11 = max(profit11, profit00-prices[i])
        return profit10
```

##### [188. 买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)
```python
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        n = len(prices)
        if n == 0 or k == 0: return 0
        # 如果交易次数>天数,当作无限次交易O(n)处理
        if k >= n:
            profit0 = 0
            profit1 = -prices[0]
            for i in range(n):
                profit0 = max(profit0, profit1+prices[i])
                profit1 = max(profit1, profit0-prices[i])
            return profit0
        profit0 = [0 for i in range(k)]
        profit1 = [-prices[0] for i in range(k)]
        for i in range(1, n):
            profit0[0] = max(profit0[0], profit1[0]+prices[i])
            profit1[0] = max(profit1[0], -prices[i])
            for j in range(1, k):
                profit0[j] = max(profit0[j], profit1[j]+prices[i])
                profit1[j] = max(profit1[j], profit0[j-1]-prices[i])
        return profit0[-1]
```

##### [714. 买卖股票的最佳时机含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)
```python
class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:
        n = len(prices)
        if n == 0: return 0
        profit0 = 0
        # 注意统一状态,fee在profit0_1处减均可,注意前后统一
        profit1 = -prices[0]-fee
        for i in range(1,n):
            profit0 = max(profit0, profit1+prices[i])
            profit1 = max(profit1, profit0-prices[i]-fee)
        return profit0
```

##### [309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        if n == 0: return 0
        profit0 = [0 for i in range(n)]
        profit1 = [-prices[0] for i in range(n)]
        for i in range(1, n):
            profit0[i] = max(profit0[i-1], profit1[i-1]+prices[i])
            profit1[i] = max(profit1[i-1], profit0[i-2]-prices[i])
        return profit0[-1]
```
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        if n == 0: return 0
        profit0 = 0
        profit1 = -prices[0]
        freeze = 0
        for i in range(n):
            # 注意储存的是前一天的状态
            prev = profit0
            profit0 = max(profit0, profit1+prices[i])
            profit1 = max(profit1, freeze-prices[i])
            freeze = prev
        return profit0
```

#### [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)
```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        n = len(s)
        if n == 0: return ""
        dp = [[0 for i in range(n)] for j in range(n)]
        for i in range(n):
            dp[i][i] = 1
        max_len, max_i, max_j = 0, 0, 0
        for i in range(n):
            for j in range(i):
                if s[i] == s[j]:
                    if i-j < 2:
                        dp[i][j] = 1
                    elif dp[i-1][j+1]:
                        dp[i][j] = 1
                if dp[i][j] and i-j > max_len:
                    max_len = i-j
                    max_i, max_j = i, j
        return s[max_j:max_i+1]
```

### 单调栈
402, 316, 42, 84, 739, 496, 503, 901
#### [402. 移掉K位数字](https://leetcode-cn.com/problems/remove-k-digits/)
给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。
```
输入: num = "1432219", k = 3
输出: "1219"
解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。
```
维护一个删除k次的单调递增栈
```python
class Solution:
    def removeKdigits(self, num: str, k: int) -> str:
        n = len(num)
        if k == n: return 0
        maintain = n - k
        stack = []
        for i in range(n):
            val = int(num[i])
            while stack and len(stack) >= i-k:
                if val < stack[-1]:
                    stack.pop()
                else:
                    break
            stack.append(val)
        print(stack)
```
#### [321. 拼接最大数](https://leetcode-cn.com/problems/create-maximum-number/)
给定长度分别为 m 和 n 的两个数组，其元素由 0-9 构成，表示两个自然数各位上的数字。现在从这两个数组中选出 k (k <= m + n) 个数字拼接成一个新的数，要求从同一个数组中取出的数字保持其在原数组中的相对顺序。求满足该条件的最大数。结果返回一个表示该最大数的长度为 k 的数组。
```
输入:
nums1 = [3, 4, 6, 5]
nums2 = [9, 1, 2, 5, 8, 3]
k = 5
输出:
[9, 8, 6, 5, 3]
```
```python
class Solution:
    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:
        """
        从nums1选取m,nums2选取k-m. 遍历i [0,k], 取最大值
        """
        def pick(m, nums):
            stack = []
            n = len(nums)
            t = n-m
            for i in range(n):
                while stack and nums[i]>stack[-1] and t>0:
                    stack.pop()
                    t -= 1
                stack.append(nums[i])
            return stack[:m]

        def merge(nums1, nums2):
            res = []
            p1, p2 = 0, 0
            while p1 < len(nums1) and p2 < len(nums2):
                # 注意,这里一定要用list比较
                if nums1[p1:] < nums2[p2:]:
                    res.append(nums2[p2])
                    p2 += 1
                else:
                    res.append(nums1[p1])
                    p1 += 1
            if p1 == len(nums1):
                res.extend(nums2[p2:])
            elif p2 == len(nums2):
                res.extend(nums1[p1:])
            return res

        max_select = [0 for i in range(k)]
        for i in range(k+1):
            if i > len(nums1) or k-i > len(nums2):
                continue
            select1 = pick(i, nums1)
            select2 = pick(k-i, nums2)
            select = merge(select1, select2)
            max_select = max(max_select, select)
        return max_select
```
#### [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)
基本思路,对每个i,其能装载的水量为, min(left_max, right_max)-curr_h
```python
class Solution:
    def trap(self, height: List[int]) -> int:
        """单调栈"""
        stack = []
        waters = 0
        for i in range(len(height)):
            while stack and height[stack[-1]] < height[i]:
                curr_i = stack.pop()
                curr_h = height[curr_i]
                if len(stack) == 0: break
                boundary = min(height[stack[-1]], height[i])
                water = (boundary - curr_h) * (i - stack[-1] - 1)
                waters += water
            stack.append(i)
        return waters
```
```python
class Solution:
    def trap(self, height: List[int]) -> int:
        """动态规划"""
        n = len(height)
        if n==0: return 0
        max_left_height = [0 for i in range(n)]
        max_right_height = [0 for i in range(n)]
        max_left_height[0] = height[0]
        max_right_height[-1] = height[-1]
        for i in range(1,n):
            max_left_height[i] = max(max_left_height[i-1], height[i])
        for i in range(n-2,-1,-1):
            max_right_height[i] = max(max_right_height[i+1], height[i])
        waters = 0
        for i in range(n):
            left_height = max_left_height[i]
            right_height = max_right_height[i]
            curr_height = height[i]
            boundary = min(left_height, right_height)
            water = boundary-curr_height
            waters += water
        return waters
```

#### [84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)
给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1
求在该柱状图中，能够勾勒出来的矩形的最大面积。
```python
class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        heights = [0] + heights + [0]
        stack = []
        n = len(heights)
        max_area = 0
        for i in range(n):
            while stack and heights[i] < stack[-1][-1]:
                last = stack.pop()
                area = last[-1] * (i - stack[-1][0] - 1)
                max_area = max(max_area, area)
            stack.append((i, heights[i]))
        return max_area
```

#### [496. 下一个更大元素 I](https://leetcode-cn.com/problems/next-greater-element-i/)
给定两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。
nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。
```
输入: nums1 = [4,1,2], nums2 = [1,3,4,2].
输出: [-1,3,-1]
```
```python
class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        """基于nums2构造单调递减栈,构造hashmap"""
        stack = []
        mapping = {}
        for i in range(len(nums2)):
            while stack and nums2[i] > stack[-1]:
                val = stack.pop()
                mapping[val] = nums2[i]
            stack.append(nums2[i])

        result = [-1 for i in range(len(nums1))]
        for i, num in enumerate(nums1):
            if num in mapping:
                result[i] = mapping[num]
        return result
```
#### [503. 下一个更大元素 II](https://leetcode-cn.com/problems/next-greater-element-ii/)
```python
class Solution:
    def nextGreaterElements(self, nums: List[int]) -> List[int]:
        stack = []
        n0 = len(nums)
        result = [-1 for i in range(n0)]
        nums = nums * 2
        for i, num in enumerate(nums):
            while stack and num > nums[stack[-1]]:
                index = stack.pop()
                if index < n0:
                    result[index] = num
            stack.append(i)
        return result
```

#### [739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)
```
根据每日 气温 列表，请重新生成一个列表，对应位置的输出是需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。
例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。
```
```python
class Solution:
    def dailyTemperatures(self, T: List[int]) -> List[int]:
        stack = []
        n = len(T)
        results = [0 for i in range(n)]
        for i in range(n):
            while stack and T[i] > T[stack[-1]]:
                index = stack.pop()
                results[index] = i - index
            stack.append(i)
        return results
```

#### [901. 股票价格跨度](https://leetcode-cn.com/problems/online-stock-span/)
```python
class StockSpanner: 
    def __init__(self):
        self.stack = []
        self.result = []
        self.cnt = 0
    def next(self, price: int) -> int:
        res = 1
        while self.stack and self.stack[-1][-1] <= price:
            index, pric = self.stack.pop()
            res += self.result[index]
        self.result.append(res)
        self.stack.append((self.cnt, price))
        self.cnt += 1
        return res
```

### 前缀和
#### [560. 和为K的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)
给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。
```
输入:nums = [1,1,1], k = 2
输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。
```
```python
class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        """O(n^2)"""
        # i, j = 0, 1
        # n = len(nums)
        # prefixsum = [0] * (n+1)
        # for i in range(n):
        #     prefixsum[i+1] = prefixsum[i] + nums[i]
        # cnt = 0
        # for i in range(n+1):
        #     for j in range(i+1, n+1):
        #         if prefixsum[j] - prefixsum[i] == k:
        #             cnt += 1
        # return cnt

        """O(n)前缀和 + memo, memo存储"""
        prefixsum = 0
        memo = {0:1} # becareful!
        cnt = 0
        for num in nums:
            prefixsum += num
            if prefixsum - k in memo:
                cnt += memo[prefixsum-k]
            if prefixsum in memo:
                memo[prefixsum] += 1
            else:
                memo[prefixsum] = 1
        return cnt
```

#### [1248. 统计优美子数组](https://leetcode-cn.com/problems/count-number-of-nice-subarrays/)
给你一个整数数组 nums 和一个整数 k。如果某个 连续 子数组中恰好有 k 个奇数数字，我们就认为这个子数组是「优美子数组」。请返回这个数组中「优美子数组」的数目。
```
输入：nums = [1,1,2,1,1], k = 3
输出：2
解释：包含 3 个奇数的子数组是 [1,1,2,1] 和 [1,2,1,1] 。
```
```python
class Solution:
    def numberOfSubarrays(self, nums: List[int], k: int) -> int:
        # odd_positions = [0]  # 设定一个数组记录奇数的位置，0代表当前位置之前的一个奇数的位置(fake point)
        # for i in range(len(nums)):
        #     if nums[i] % 2 == 1:
        #         odd_positions.append(i + 1)  # 将位置压入
        # odd_positions.append(len(nums) + 1)  # len(nums)+1代表最后一个奇数位之后的奇数位置(fake point)
        # count = 0
        # for i in range(1, len(odd_positions) - k):
        #     # 当前奇数位置 i 到前一个奇数位置之间选一个位置 * i 后的第 k-1 个奇数的位置到 i 后的第 k 个奇数节点范围内选一个
        #     count += ((odd_positions[i] - odd_positions[i - 1]) *
        #               (odd_positions[i + k] - odd_positions[i + k - 1]))  # 组合数
        # return count

        """
        pre_fix: 到当前index累计奇数的个数
        pre_fix_count: 记录每个奇数个数下的不同的连续数组个数
        """
        pre_fix_count = [1] + [0] * len(nums)
        pre_fix = 0
        result = 0
        for i in range(len(nums)):
            odd = 1 if nums[i] % 2 == 1 else 0
            pre_fix += odd
            pre_fix_count[pre_fix] += 1
            if pre_fix >= k:
                result += pre_fix_count[pre_fix - k]
        print(pre_fix_count)
        return result
```

#### 二叉树

#### [1371. 每个元音包含偶数次的最长子字符串](https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/)
TODO: 再理解一下
```python
class Solution:
    def findTheLongestSubstring(self, s: str) -> int:
        res = 0
        state = [-1] * (1 << 5)
        cur, state[0] = 0, 0
        d = dict(zip('aeiou', range(5)))
        for idx, val in enumerate(s):
            tmp = -1
            if val in d:
                tmp = d[val]
            if tmp != -1:
                cur ^= 1 << tmp
            if state[cur] == -1:
                state[cur] = idx + 1
            else:
                res = max(res, idx + 1 - state[cur])
        return res
```

### 树
#### 建树
##### [108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
        def helper(left, right):
            if left >= right: return None
            mid = left + (right-left)//2
            root = TreeNode(nums[mid])
            root.left = helper(left, mid)
            root.right = helper(mid+1, right)
            return root
        return helper(0, len(nums))
```

##### [面试题07. 重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/) [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        n = len(preorder)
        # 建立哈希表，实现O(1)查询
        lookup_table = {inorder[i]: i for i in range(n)}
        # 递归中维护子树根index与子树区间范围(相对于preorder)
        def helper(root_i, left, right):
            # 如果区间相交，return叶子节点的None
            if left >= right: return
            root = TreeNode(preorder[root_i])
            # 查询子树根在中序遍历中的位置
            in_i = lookup_table[preorder[root_i]]
            # 左子树root index 根+1
            root.left = helper(root_i+1, left, in_i)
            # 右子树root index 根+左子树长度+1
            root.right = helper(root_i+in_i-left+1, in_i+1, right)
            # 层层向上返回子树的根
            return root

        root = helper(0, 0, n)
        return root
```

### 滑动窗口
#### [76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)
维护两个窗口window_s, window_t, 一个变量curr. 当window_s覆盖了window_t, 移动左指针.
实现时, 用变量curr, 突破与下降临界时curr变动, 复杂度从用isvalid的O(n^2)降到O(n)
```python
from collections import Counter, defaultdict
class Solution:
    def isvalid(self, dict1, dict2):
        valid = True
        for key in dict1:
            if key in dict2 and dict1[key] <= dict2[key]:
                continue
            else:
                valid = False
                break
        return valid

    def minWindow(self, s: str, t: str) -> str:
        l, r = 0, 0
        window_s = defaultdict(int)
        window_t = Counter(t)
        require = len(window_t)
        curr = 0

        min_l, min_r, min_len = 0, 0, float("inf")
        while r < len(s):
            window_s[s[r]] += 1
            if window_s[s[r]] == window_t[s[r]]:
                curr += 1

            while l<=r and curr == require:
                if r-l+1 < min_len:
                    min_len = r-l+1
                    min_l = l
                    min_r = r
                if window_s[s[l]] == window_t[s[l]]:
                    curr -= 1
                window_s[s[l]] -= 1
                l += 1
            r += 1
        ans = s[min_l:min_r+1] if min_len != float("inf") else ""
        return ans
```
3. 无重复字符的最长子串

30. 串联所有单词的子串

76. 最小覆盖子串

159. 至多包含两个不同字符的最长子串

209. 长度最小的子数组

239. 滑动窗口最大值

567. 字符串的排列

632. 最小区间

727. 最小窗口子序列
