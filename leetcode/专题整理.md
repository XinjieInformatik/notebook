# Leetcode 专题整理

### 动态规划
#### 最大子序问题
1. 定义状态
2. 推导状态转移方程
3. 初始化
4. 输出

##### [152. 乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/)
```python
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        """
        dp[i][0]: 到数组index为i的元素,最近一段连续的最小乘积
        dp[i][1]: 到数组index为i的元素,最近一段连续的最大乘积
        """
        n = len(nums)
        # 注意２在里面，ｎ在外面
        dp = [[0 for i in range(2)] for j in range(n)]
        # 初始化
        if n == 0: return None
        dp[0][0], dp[0][1] = nums[0], nums[0]
        res = nums[0]
        for i in range(1, n):
            # nums[i] 为正负 两种情况下状态的改变
            if nums[i] > 0:
                # min 的意思为可以在这里截断，dp[i-1]维护的是上一段连续乘积
                dp[i][0] = min(dp[i-1][0]*nums[i], nums[i])
                dp[i][1] = max(dp[i-1][1]*nums[i], nums[i])
            else:
                # 最大值变为最小值，最小值变为最大值
                dp[i][0] = min(dp[i-1][1]*nums[i], nums[i])
                dp[i][1] = max(dp[i-1][0]*nums[i], nums[i])
            res = max(res, dp[i][1])
        return res
```

滚动数组,空间优化
```python
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        """ 滚动变量
        curr_min: 到数组当前index,最近一段连续的最小乘积
        curr_max: 到数组当前index,最近一段连续的最大乘积
        注意 prev <-> curr 之间的转化
        """
        n = len(nums)
        prev_max, prev_min, res = nums[0], nums[0], nums[0]
        for i in range(1, n):
            if nums[i] > 0:
                curr_min = min(nums[i], prev_min*nums[i])
                curr_max = max(nums[i], prev_max*nums[i])
            else:
                curr_min = min(nums[i], prev_max*nums[i])
                curr_max = max(nums[i], prev_min*nums[i])
            prev_min, prev_max = curr_min, curr_max
            res = max(res, curr_max)
        return res
```

##### [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)
```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        """
        dp[i]: 到数组i的最近一段最大和
        注意return res 而不是dp[-1]
        """
        n = len(nums)
        dp = [0 for i in range(n)]
        dp[0], res = nums[0], nums[0]
        for i in range(1, n):
            dp[i] = max(dp[i-1]+nums[i], nums[i])
            res = max(dp[i], res)
        return res
```
```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        n = len(nums)
        prev, res = nums[0], nums[0]
        for i in range(1, n):
            curr = max(prev+nums[i], nums[i])
            prev = curr
            res = max(res, curr)
        return res
```

##### [300. 最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)
```python
class Solution:
    def low_bound(self, nums, left, right, target):
        while left < right:
            mid = left + (right-left) // 2
            if nums[mid] < target:
                left = mid + 1
            else:
                right = mid
        return left

    def lengthOfLIS(self, nums: List[int]) -> int:
        dp = []
        lenth = 0
        n = len(nums)
        for i in range(n):
            if lenth == 0:
                dp.append(nums[i])
                lenth += 1
            index = self.low_bound(dp, 0, lenth, nums[i])
            if index < lenth:
                dp[index] = nums[i]
            else:
                dp.append(nums[i])
                lenth += 1
        return len(dp)
```

##### [376. 摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/)
```python
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        """
        up[i]  : 到nums[i]为止最长的上升摆动序列
        down[i]: 到nums[i]为止最长的下降摆动序列
        """
        n = len(nums)
        if n == 0: return 0
        up = [0 for i in range(n)]
        down = [0 for i in range(n)]
        up[0], down[0] = 1, 1
        for i in range(1, n):
            if nums[i] > nums[i-1]:
                up[i] = down[i-1] + 1
                down[i] = down[i-1]
            elif nums[i] < nums[i-1]:
                up[i] = up[i-1]
                down[i] = up[i-1] + 1
            else:
                up[i] = up[i-1]
                down[i] = down[i-1]
        return max(up[-1], down[-1])
```

##### [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        if n == 0: return 0
        min_price = prices[0]
        max_profit = 0
        for i in range(1, n):
            profit = prices[i] - min_price
            max_profit = max(max_profit, profit)
            min_price = min(min_price, prices[i])
        return max_profit
```
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        """
        profit0: 状态为手中无股票的最大收益
        profit1: 状态为手中有股票的最大收益
        """
        n = len(prices)
        if n == 0: return 0
        profit0 = 0
        profit1 = - prices[0]
        for i in range(n):
            profit0 = max(profit0, profit1+prices[i])
            profit1 = max(profit1, -prices[i])
        return profit0
```

##### [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        if n == 0: return 0
        profit0 = 0
        profit1 = -prices[0]
        for i in range(1, n):
            profit0 = max(profit0, profit1+prices[i])
            profit1 = max(profit1, profit0-prices[i])
        return profit0
```

##### [123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        if n == 0: return 0
        profit00 = 0
        profit01 = -prices[0]
        profit10 = 0
        profit11 = -prices[0]
        for i in range(n):
            profit00 = max(profit00, profit01+prices[i])
            profit01 = max(profit01, -prices[i])
            profit10 = max(profit10, profit11+prices[i])
            profit11 = max(profit11, profit00-prices[i])
        return profit10
```

##### [188. 买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)
```python
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        n = len(prices)
        if n == 0 or k == 0: return 0
        # 如果交易次数>天数,当作无限次交易O(n)处理
        if k >= n:
            profit0 = 0
            profit1 = -prices[0]
            for i in range(n):
                profit0 = max(profit0, profit1+prices[i])
                profit1 = max(profit1, profit0-prices[i])
            return profit0
        profit0 = [0 for i in range(k)]
        profit1 = [-prices[0] for i in range(k)]
        for i in range(1, n):
            profit0[0] = max(profit0[0], profit1[0]+prices[i])
            profit1[0] = max(profit1[0], -prices[i])
            for j in range(1, k):
                profit0[j] = max(profit0[j], profit1[j]+prices[i])
                profit1[j] = max(profit1[j], profit0[j-1]-prices[i])
        return profit0[-1]
```

##### [714. 买卖股票的最佳时机含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)
```python
class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:
        n = len(prices)
        if n == 0: return 0
        profit0 = 0
        # 注意统一状态,fee在profit0_1处减均可,注意前后统一
        profit1 = -prices[0]-fee
        for i in range(1,n):
            profit0 = max(profit0, profit1+prices[i])
            profit1 = max(profit1, profit0-prices[i]-fee)
        return profit0
```

##### [309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        if n == 0: return 0
        profit0 = [0 for i in range(n)]
        profit1 = [-prices[0] for i in range(n)]
        for i in range(1, n):
            profit0[i] = max(profit0[i-1], profit1[i-1]+prices[i])
            profit1[i] = max(profit1[i-1], profit0[i-2]-prices[i])
        return profit0[-1]
```
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        if n == 0: return 0
        profit0 = 0
        profit1 = -prices[0]
        freeze = 0
        for i in range(n):
            # 注意储存的是前一天的状态
            prev = profit0
            profit0 = max(profit0, profit1+prices[i])
            profit1 = max(profit1, freeze-prices[i])
            freeze = prev
        return profit0
```

#### [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)
```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        n = len(s)
        if n == 0: return ""
        dp = [[0 for i in range(n)] for j in range(n)]
        for i in range(n):
            dp[i][i] = 1
        max_len, max_i, max_j = 0, 0, 0
        for i in range(n):
            for j in range(i):
                if s[i] == s[j]:
                    if i-j < 2:
                        dp[i][j] = 1
                    elif dp[i-1][j+1]:
                        dp[i][j] = 1
                if dp[i][j] and i-j > max_len:
                    max_len = i-j
                    max_i, max_j = i, j
        return s[max_j:max_i+1]
```

### 单调栈
402, 316, 42, 84, 739, 496, 503, 901

### 前缀和


#### [560. 和为K的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)
给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。
```
输入:nums = [1,1,1], k = 2
输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。
```
```python
class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        """O(n^2)"""
        # i, j = 0, 1
        # n = len(nums)
        # prefixsum = [0] * (n+1)
        # for i in range(n):
        #     prefixsum[i+1] = prefixsum[i] + nums[i]
        # cnt = 0
        # for i in range(n+1):
        #     for j in range(i+1, n+1):
        #         if prefixsum[j] - prefixsum[i] == k:
        #             cnt += 1
        # return cnt

        """O(n)前缀和 + memo, memo存储"""
        prefixsum = 0
        memo = {0:1} # becareful!
        cnt = 0
        for num in nums:
            prefixsum += num
            if prefixsum - k in memo:
                cnt += memo[prefixsum-k]
            if prefixsum in memo:
                memo[prefixsum] += 1
            else:
                memo[prefixsum] = 1
        return cnt
```

#### [1248. 统计优美子数组](https://leetcode-cn.com/problems/count-number-of-nice-subarrays/)
给你一个整数数组 nums 和一个整数 k。如果某个 连续 子数组中恰好有 k 个奇数数字，我们就认为这个子数组是「优美子数组」。请返回这个数组中「优美子数组」的数目。
```
输入：nums = [1,1,2,1,1], k = 3
输出：2
解释：包含 3 个奇数的子数组是 [1,1,2,1] 和 [1,2,1,1] 。
```
```python
class Solution:
    def numberOfSubarrays(self, nums: List[int], k: int) -> int:
        # odd_positions = [0]  # 设定一个数组记录奇数的位置，0代表当前位置之前的一个奇数的位置(fake point)
        # for i in range(len(nums)):
        #     if nums[i] % 2 == 1:
        #         odd_positions.append(i + 1)  # 将位置压入
        # odd_positions.append(len(nums) + 1)  # len(nums)+1代表最后一个奇数位之后的奇数位置(fake point)
        # count = 0
        # for i in range(1, len(odd_positions) - k):
        #     # 当前奇数位置 i 到前一个奇数位置之间选一个位置 * i 后的第 k-1 个奇数的位置到 i 后的第 k 个奇数节点范围内选一个
        #     count += ((odd_positions[i] - odd_positions[i - 1]) *
        #               (odd_positions[i + k] - odd_positions[i + k - 1]))  # 组合数
        # return count

        """
        pre_fix: 到当前index累计奇数的个数
        pre_fix_count: 记录每个奇数个数下的不同的连续数组个数
        """
        pre_fix_count = [1] + [0] * len(nums)
        pre_fix = 0
        result = 0
        for i in range(len(nums)):
            odd = 1 if nums[i] % 2 == 1 else 0
            pre_fix += odd
            pre_fix_count[pre_fix] += 1
            if pre_fix >= k:
                result += pre_fix_count[pre_fix - k]
        print(pre_fix_count)
        return result
```

#### 二叉树

#### [1371. 每个元音包含偶数次的最长子字符串](https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/)
TODO: 再理解一下
```python
class Solution:
    def findTheLongestSubstring(self, s: str) -> int:
        res = 0
        state = [-1] * (1 << 5)
        cur, state[0] = 0, 0
        d = dict(zip('aeiou', range(5)))
        for idx, val in enumerate(s):
            tmp = -1
            if val in d:
                tmp = d[val]
            if tmp != -1:
                cur ^= 1 << tmp
            if state[cur] == -1:
                state[cur] = idx + 1
            else:
                res = max(res, idx + 1 - state[cur])
        return res
```
