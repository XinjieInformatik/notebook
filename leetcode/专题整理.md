# Leetcode 专题整理

### 动态规划
#### 最大子序问题
1. 定义状态
2. 推导状态转移方程
3. 初始化
4. 输出

##### [152. 乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/)
```python
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        """
        dp[i][0]: 到数组index为i的元素,最近一段连续的最小乘积
        dp[i][1]: 到数组index为i的元素,最近一段连续的最大乘积
        """
        n = len(nums)
        # 注意２在里面，ｎ在外面
        dp = [[0 for i in range(2)] for j in range(n)]
        # 初始化
        if n == 0: return None
        dp[0][0], dp[0][1] = nums[0], nums[0]
        res = nums[0]
        for i in range(1, n):
            # nums[i] 为正负 两种情况下状态的改变
            if nums[i] > 0:
                # min 的意思为可以在这里截断，dp[i-1]维护的是上一段连续乘积
                dp[i][0] = min(dp[i-1][0]*nums[i], nums[i])
                dp[i][1] = max(dp[i-1][1]*nums[i], nums[i])
            else:
                # 最大值变为最小值，最小值变为最大值
                dp[i][0] = min(dp[i-1][1]*nums[i], nums[i])
                dp[i][1] = max(dp[i-1][0]*nums[i], nums[i])
            res = max(res, dp[i][1])
        return res
```

滚动数组,空间优化
```python
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        """ 滚动变量
        curr_min: 到数组当前index,最近一段连续的最小乘积
        curr_max: 到数组当前index,最近一段连续的最大乘积
        注意 prev <-> curr 之间的转化
        """
        n = len(nums)
        prev_max, prev_min, res = nums[0], nums[0], nums[0]
        for i in range(1, n):
            if nums[i] > 0:
                curr_min = min(nums[i], prev_min*nums[i])
                curr_max = max(nums[i], prev_max*nums[i])
            else:
                curr_min = min(nums[i], prev_max*nums[i])
                curr_max = max(nums[i], prev_min*nums[i])
            prev_min, prev_max = curr_min, curr_max
            res = max(res, curr_max)
        return res
```

##### [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)
```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        """
        dp[i]: 到数组i的最近一段最大和
        注意return res 而不是dp[-1]
        """
        n = len(nums)
        dp = [0 for i in range(n)]
        dp[0], res = nums[0], nums[0]
        for i in range(1, n):
            dp[i] = max(dp[i-1]+nums[i], nums[i])
            res = max(dp[i], res)
        return res
```
```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        n = len(nums)
        prev, res = nums[0], nums[0]
        for i in range(1, n):
            curr = max(prev+nums[i], nums[i])
            prev = curr
            res = max(res, curr)
        return res
```

##### [300. 最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)
```python
class Solution:
    def low_bound(self, nums, left, right, target):
        while left < right:
            mid = left + (right-left) // 2
            if nums[mid] < target:
                left = mid + 1
            else:
                right = mid
        return left

    def lengthOfLIS(self, nums: List[int]) -> int:
        dp = []
        lenth = 0
        n = len(nums)
        for i in range(n):
            if lenth == 0:
                dp.append(nums[i])
                lenth += 1
            index = self.low_bound(dp, 0, lenth, nums[i])
            if index < lenth:
                dp[index] = nums[i]
            else:
                dp.append(nums[i])
                lenth += 1
        return len(dp)
```

##### [376. 摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/)
```python
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        """
        up[i]  : 到nums[i]为止最长的上升摆动序列
        down[i]: 到nums[i]为止最长的下降摆动序列
        """
        n = len(nums)
        if n == 0: return 0
        up = [0 for i in range(n)]
        down = [0 for i in range(n)]
        up[0], down[0] = 1, 1
        for i in range(1, n):
            if nums[i] > nums[i-1]:
                up[i] = down[i-1] + 1
                down[i] = down[i-1]
            elif nums[i] < nums[i-1]:
                up[i] = up[i-1]
                down[i] = up[i-1] + 1
            else:
                up[i] = up[i-1]
                down[i] = down[i-1]
        return max(up[-1], down[-1])
```

##### [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        if n == 0: return 0
        min_price = prices[0]
        max_profit = 0
        for i in range(1, n):
            profit = prices[i] - min_price
            max_profit = max(max_profit, profit)
            min_price = min(min_price, prices[i])
        return max_profit
```
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        """
        profit0: 状态为手中无股票的最大收益
        profit1: 状态为手中有股票的最大收益
        """
        n = len(prices)
        if n == 0: return 0
        profit0 = 0
        profit1 = - prices[0]
        for i in range(n):
            profit0 = max(profit0, profit1+prices[i])
            profit1 = max(profit1, -prices[i])
        return profit0
```

##### [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        if n == 0: return 0
        profit0 = 0
        profit1 = -prices[0]
        for i in range(1, n):
            profit0 = max(profit0, profit1+prices[i])
            profit1 = max(profit1, profit0-prices[i])
        return profit0
```

##### [123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        if n == 0: return 0
        profit00 = 0
        profit01 = -prices[0]
        profit10 = 0
        profit11 = -prices[0]
        for i in range(n):
            profit00 = max(profit00, profit01+prices[i])
            profit01 = max(profit01, -prices[i])
            profit10 = max(profit10, profit11+prices[i])
            profit11 = max(profit11, profit00-prices[i])
        return profit10
```

##### [188. 买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)
```python
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        n = len(prices)
        if n == 0 or k == 0: return 0
        # 如果交易次数>天数,当作无限次交易O(n)处理
        if k >= n:
            profit0 = 0
            profit1 = -prices[0]
            for i in range(n):
                profit0 = max(profit0, profit1+prices[i])
                profit1 = max(profit1, profit0-prices[i])
            return profit0
        profit0 = [0 for i in range(k)]
        profit1 = [-prices[0] for i in range(k)]
        for i in range(1, n):
            profit0[0] = max(profit0[0], profit1[0]+prices[i])
            profit1[0] = max(profit1[0], -prices[i])
            for j in range(1, k):
                profit0[j] = max(profit0[j], profit1[j]+prices[i])
                profit1[j] = max(profit1[j], profit0[j-1]-prices[i])
        return profit0[-1]
```

##### [714. 买卖股票的最佳时机含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)
```python
class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:
        n = len(prices)
        if n == 0: return 0
        profit0 = 0
        # 注意统一状态,fee在profit0_1处减均可,注意前后统一
        profit1 = -prices[0]-fee
        for i in range(1,n):
            profit0 = max(profit0, profit1+prices[i])
            profit1 = max(profit1, profit0-prices[i]-fee)
        return profit0
```

##### [309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        if n == 0: return 0
        profit0 = [0 for i in range(n)]
        profit1 = [-prices[0] for i in range(n)]
        for i in range(1, n):
            profit0[i] = max(profit0[i-1], profit1[i-1]+prices[i])
            profit1[i] = max(profit1[i-1], profit0[i-2]-prices[i])
        return profit0[-1]
```
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        if n == 0: return 0
        profit0 = 0
        profit1 = -prices[0]
        freeze = 0
        for i in range(n):
            # 注意储存的是前一天的状态
            prev = profit0
            profit0 = max(profit0, profit1+prices[i])
            profit1 = max(profit1, freeze-prices[i])
            freeze = prev
        return profit0
```
