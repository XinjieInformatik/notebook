# 工厂模式

工厂模式的多态的一个典型应用，在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。
- 工厂方法：多个工厂类，一个产品抽象类，利用多态创建不同的产品对象，避免了大量的if-else判断。
- 抽象工厂：多个工厂类，多个产品抽象类，产品子类分组，同一个工厂实现类创建同组中的不同产品，减少了工厂子类的数量。


## 工厂方法 模式

```python
from abc import ABC, abstractmethod
class Creator(ABC):
    @abstractmethod
    def factory_method(self):
        # 需要各自子类去实现的工厂方法
        pass

    def some_operation(self) -> str:
        # 暴露给客户端的通用接口
        product = self.factory_method()
        result = f"Creator: The same creator's code has just worked with {product.operation()}"

        return result
    
class ConcreteCreator1(Creator):
    def factory_method(self) -> Product:
        return ConcreteProduct1()


class ConcreteCreator2(Creator):
    def factory_method(self) -> Product:
        return ConcreteProduct2()
```

```python
class Product(ABC):
    @abstractmethod
    def operation(self) -> str:
        pass

class ConcreteProduct1(Product):
    def operation(self) -> str:
        return "{Result of the ConcreteProduct1}"


class ConcreteProduct2(Product):
    def operation(self) -> str:
        return "{Result of the ConcreteProduct2}"
```

```python
def client_code(creator: Creator) -> None:
    print(f"Client: I'm not aware of the creator's class, but it still works.\n"
          f"{creator.some_operation()}", end="")


if __name__ == "__main__":
    print("App: Launched with the ConcreteCreator1.")
    client_code(ConcreteCreator1())

    print("App: Launched with the ConcreteCreator2.")
    client_code(ConcreteCreator2())
```

## 抽象工厂 模式
核心：工厂 / 产品之间进行聚类
```python
from abc import ABC, abstractmethod

class AbstractFactory(ABC):
    @abstractmethod
    def create_car_body(self) -> AbstractCarBody:
        pass

    @abstractmethod
    def create_car_wheel(self) -> AbstractCarWheel:
        pass


class TeslaFactory(AbstractFactory):
    def create_car_body(self) -> AbstractCarBody:
        return TeslaCarBody()

    def create_car_wheel(self) -> AbstractCarWheel:
        return TeslaCarWheel()


class BenzFactory(AbstractFactory):
    def create_car_body(self) -> AbstractCarBody:
        return BenzCarBody()

    def create_car_wheel(self) -> AbstractCarWheel:
        return BenzCarWheel()
```

```python
class AbstractCarBody(ABC):
    @abstractmethod
    def function_car_body(self) -> str:
        pass

class TeslaCarBody(AbstractCarBody):
    def function_car_body(self) -> str:
        return "The result of the product A1."

class BenzCarBody(AbstractCarBody):
    def function_car_body(self) -> str:
        return "The result of the product A2."
        

class AbstractCarWheel(ABC):
    @abstractmethod
    def function_car_wheel(self) -> None:
        pass

    @abstractmethod
    def function_assemble(self, collaborator: AbstractCarBody) -> None:
        pass

class TeslaCarWheel(AbstractCarWheel):
    def function_car_wheel(self) -> str:
        return "The result of the product B1."
        
    def function_assemble(self, collaborator: AbstractCarBody) -> str:
        result = collaborator.function_car_body()
        return f"The result of the B1 collaborating with the ({result})"


class BenzCarWheel(AbstractCarWheel):
    def function_car_wheel(self) -> str:
        return "The result of the product B2."

    def function_assemble(self, collaborator: AbstractCarBody):
        result = collaborator.function_car_body()
        return f"The result of the B2 collaborating with the ({result})"
```

```python
def client_code(factory: AbstractFactory) -> None:
    car_body = factory.create_car_body()
    car_wheel = factory.create_car_wheel()

    print(f"{car_wheel.function_car_wheel()}")
    print(f"{car_wheel.function_assemble(car_body)}", end="")


if __name__ == "__main__":
    print("Client: Testing client code with the first factory type:")
    client_code(TeslaFactory())
    
    print("Client: Testing the same client code with the second factory type:")
    client_code(BenzFactory())
```
